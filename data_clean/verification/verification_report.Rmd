---
title: "Verification Report: data_clean"
author: "Ellis Hughes"
date: "`r Sys.Date()`"
output: pdf_document
---

```{r setup, include=FALSE}

renv::activate(here::here())

knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(testthat)
library(here)

```

```{r helper-functions, include=FALSE}
quiet<-function(x,func,...){
  x2<-try(suppressWarnings(func(x,...)),silent = TRUE)
  if(inherits(x2,'try-error')){
    return(x)
  }else{
    return(x2)
  }
}

naturalize <- function(x, round_digits = NA){
  NAs <- sum(is.na(x)| x=="NaN")
  date_formats<-c("%Y/%m/%d","%Y-%m-%d","%d-%b-%Y")
  if(sum(is.na(quiet(x,as.numeric))) == NAs){
    x <- quiet(x,as.numeric)
    if(!is.na(round_digits)){
      x <- round(x,round_digits)
    }
    return(x)
  }else if(sum(is.na(quiet(x,as.Date,tryFormats = date_formats))) == NAs){
    return(quiet(x,as.Date,tryFormats = date_formats))
  }else{
    return(x)
  }
}

# Equal test to include NA comparisons as T/F
equal <- function(x1,x2, threshold){
  
  if (is.numeric(x1) & threshold != 0) {
    x1 <- abs(x1 - x2) <= threshold
    x2_tmp <- rep(TRUE, length(x2))
    x2_tmp[is.na(x2)] <- NA
    x2 <- x2_tmp
  }
  
  c <- as.character(x1) == as.character(x2)
  c[ is.na(x1) | is.na(x2) ] <- (is.na(x1) == is.na(x2) )[ is.na(x1) | is.na(x2) ]
  c
  
}

compare_datasets <- function(cols,ds1,ds2,index, verbose = TRUE, round_digits = NA, thresholds = sqrt(.Machine$double.eps)){
  res <- lapply(cols,function(column_name){
    
    if(is.list(round_digits)){
      if(column_name %in% names(round_digits)){
        round_digit <- round_digits[[column_name]]
      }else{
        round_digit <- round_digits[[".default"]]
      }
    }else{
      round_digit <- round_digits
    }
    
    if(is.list(thresholds)){
      if(column_name %in% names(thresholds)){
        threshold <- thresholds[[column_name]]
      }else{
        threshold <- thresholds[[".default"]]
      }
    }else{
      threshold <- thresholds
    }
    
    
    
    v1 <- naturalize( ds1[ order( ds1[[index]] ), column_name, drop = TRUE], round_digits = round_digit)
    v2 <- naturalize( ds2[ order( ds2[[index]] ), column_name, drop = TRUE], round_digits = round_digit)
    is_equal <- equal( v1, v2 , threshold = threshold)
    if ( !all( is_equal ) & verbose)
      print( paste0("`", column_name, "` is not equal. ", sum(!is_equal),"/", max(length(v1),length(v2)), " mismatches." ) )
    
    
    
    return( list(
      equal = all( is_equal ),
      diffs = data.frame(
        key = sort(ds1[[index]])[!is_equal],
        ds1 = v1[!is_equal],
        ds2 = v2[!is_equal],
        stringsAsFactors = FALSE
        ))
      )
  })
  
  names(res) <- cols
  
  resmatched <- do.call( 'c', lapply(res,`[[`,1))
  if( verbose ){
    message( "There are ", sum(!resmatched), " mismatched fields of ", length(resmatched),'.')
  }
  
  attr(res,"index") <- index
  
  class(res) <- "comparison"
  return( res )
}

print.comparison <- function(x,...){
  n_mismatch <- do.call('c',lapply(x,function(y){
    z <- nrow(y$diffs)
    if(z>0){
      z
    }else{
      NULL
    }
  }))
  
  for(comp in names(n_mismatch)){
      message( paste0("`", comp, "` is not equal. ", n_mismatch[[comp]], " mismatches." ) )
  }
}

rerun_failed_comparisons <- function( x, ds1, ds2){
  mismatched <- names(do.call('c',lapply(x,function(y){
    if(nrow(y$diffs)>0){
      1
    }else{
      NULL
    }
  })))
  compare_datasets(mismatched, ds1, ds2, index = attr(x,"index"))
}

reformat <- function(x, digits = 1){
  format(round(as.numeric(x),digits = digits), nsmall = digits)
}

```

## Description

This is the verification report for the `data_clean` folder of the `correlates_reporting` project for CoVPN. 

In this document, the output of `make_data_proc.R` is compared against the output of `process_data_raw.R`. The two scripts use the same base mock data. The two datasets generated by each of the two scripts will be compared with each other to confirm they contain the same values.

`process_data_raw.R` was independently double programmed based on the specifications found in `dat_clean_specifications.pdf`. This script outputs its processing to \newline `data_clean/verification/verification_output/data_clean_verification_output.csv`

The file `data_clean/verification/verification_input/practice_data.csv` was provided by the original programmer to the tester for verification purposes of `make_data_proc.R` when all time points are available.s
Its md5 hash is `r digest::digest(file = here("data_clean/verification/verification_input","practice_data.csv"))`.

The file `data_clean/verification/verification_input/practice_data_wo29.csv` was provided by the original programmer to the tester for verification purposes of `make_data_proc.R` when only baseline and Day 57 were available.
Its md5 hash is `r digest::digest(file = here("data_clean/verification/verification_input","practice_data_wo29.csv"))`.


The file `data_clean/verification/verification_output/data_clean_verification_output.csv` was created by the tester for verification using the `process_data_Raw.R` script and using all time points available.
Its md5 hash is `r digest::digest(file = here("data_clean/verification/verification_output/data_clean_verification_output.csv"))`.


The file `data_clean/verification/verification_output/data_clean_verification_output_no_d29.csv` was created by the tester for verification using the `process_data_Raw.R` script and using only the time points Baseline and Day 57.
Its md5 hash is `r digest::digest(file = here("data_clean/verification/verification_output/data_clean_verification_output_no_d29.csv"))`.

### Load Data

```{r Load-Data, message=FALSE}
original_data <- read_csv(
  here("data_clean/verification/verification_input","practice_data.csv"),
  guess_max = 30000)

original_data_no_d29 <- read_csv(
  here("data_clean/verification/verification_input","practice_data_wo29.csv"),
  guess_max = 30000)

verification_data <- read_csv(
  here("data_clean/verification/verification_output/data_clean_verification_output.csv"),
  guess_max = 30000)

verification_data_no_d29 <- read_csv(
  here("data_clean/verification/verification_output/data_clean_verification_output_no_D29.csv"),
  guess_max = 30000)
```

## Verification

```{r comparison-full}

data_clean_comparison <- compare_datasets(
  cols =  colnames(original_data), index = "Ptid",
  ds1 = original_data, ds2 = verification_data
)

data_clean_comparison_no_d29 <- compare_datasets(
  cols = colnames(original_data_no_d29), index = "Ptid",
  ds1 = original_data_no_d29, ds2 = verification_data_no_d29
)

```

```{r echo=FALSE}

clean_comparison_pass <- all(sapply(data_clean_comparison, `[[`, "equal"))
clean_comparison_pass_no_d29 <- all(sapply(data_clean_comparison_no_d29, `[[`, "equal"))

```

Output of `make_data_proc.R` is `r ifelse(clean_comparison_pass, "equivalent to","different from")` the output of `process_data_raw.R` for cases when all time points are available. Output of `make_data_proc.R` is `r ifelse(clean_comparison_pass, "equivalent to","different from")` the output of `process_data_raw.R` for cases when only Baseline and Day 57 are available. `make_data_proc.R` `r ifelse(clean_comparison_pass && clean_comparison_pass_no_d29, "passes","fails")` verification.

## Signatures

```{r echo = FALSE, message = FALSE, tidy = FALSE, cache = FALSE, results = 'asis'}
suppressWarnings({
suppressPackageStartupMessages({
library(knitr)
library(kableExtra)
library(tibble)
})})

options(kableExtra.latex.load_packages = FALSE, 
        knitr.table.format = "latex",
        knitr.kable.NA = '',
        width = 40,
        usethis.quiet = TRUE)

signature_table <- function(people){
  # check that the tables have correct variables
  if (!all(c("role", "name") %in% tolower(names(people)))) {
    stop(paste0("people table must have variables: role and name. ",
                "Contains: ", paste0(tolower(names(people)), collapse = ", ")))
  }
  
  people$signature <- NA
  people$date <- NA
  names(people) <- tolower(names(people))
  people[, c("role", "name", "signature", "date")] %>% 
  kable(col.names = c("Role", "Name", "Signature", "Date"),
        escape = FALSE, booktabs = FALSE) %>% 
    kable_styling(full_width = FALSE, position = "left") %>% 
    row_spec(0, background = rgb(184, 204, 228, maxColorValue = 255)) %>% 
    column_spec(1, width = "9em", border_left = TRUE) %>% 
    column_spec(2, width = "11em") %>% 
    column_spec(3, width = "15em") %>% 
    column_spec(4, width = "8em", border_right = TRUE)
}

tibble::tribble(
  ~ name,                ~ role,
  "Ellis Hughes",  "Tester"
) %>% 
  signature_table()
```
